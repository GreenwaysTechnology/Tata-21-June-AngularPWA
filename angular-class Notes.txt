@angular - @ means private npm package

@angular/core

<app-root></app-root> -----| custom element
           |
           -------------------|main.js-----app.module.js----app.component.js

			      main.ts------app.module.ts----app.component.ts


main method

Angular supports lot of built in decorators.

 Component ContentChild ContentChildren Directive Host HostBinding HostListener Inject Injectable Input NgModule Optional Output Pipe Self SkipSelf ViewChild ViewChildren

component

-declare class
-decorator - decorate class makes corresponding object.

component

- class 

-decorator
  is function
  takes args - decorator meta data
  meta data - is object in angular


Template:

 - inline template -  as part of component

 - external template  separate file and linked

@Component({
  selector: 'app-root', // tag name
  // template: `
  //     <h1>Tata Technologies </h1>  
  // `
  templateUrl: './app.component.html'
})
export class AppComponent {

}


//
object creations

 let app = new AppComponent()

in angular we dont create infra objects- angular create automatically.

   injector system.


Depedency injection

- automation
 object creation
    +
 refer created object inside object  

how to tell angular to create objects.

Angular never creates objects until you tell -  you configure.

Angular creates infra objects only. via decorator.

Even though angular uses infra objects, never creates them until you tell.

Where you can tell?

 inside another object called "Module" - AppModule.


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
/////////////////////////////////////////////////////////////////////////////////////////////

Coding Best practice:

<app-root>
  ? - ?
  
file names:

domainname.component/service/directive/pipe/module /.spec.ts/html/css

hero.component.ts|html|css|spec
hero.service.ts
hero.directive.ts

hero.component.ts
hero.component.css
hero.component.html

tag name:
Do use dashed-case or kebab-case for naming the element selectors of components.

app-hero  : dash case / kekab-case

class Names

-Do use upper camel case for class names.
-Do match the name of the symbol to the name of the file.
-Do append the symbol name with the conventional suffix x (such as Component, Directive, Module, Pipe, or Service) for a thing of that type.
   CustomerComponent, CustomerService, CustomerDirective CustomerPipe ..

Do give the filename the conventional suffix (such as .component.ts, .directive.ts, .module.ts, .pipe.ts, or .service.ts) for a file of that type.

   customer.component.ts    ----export class CustomerComponent { }
   customer.module.ts
   customer.pipe.ts
   etc...

modularaization:

1.break app into files and folders

app - main folder -  only root files - module,component
 |
 greeter
 customer
 product
 utils
 services
 directives
 pipes

Component driven arch:

 as much as possible we have break component ; 


Angular dev tool

///////////////////////////////////////////////////////////////////////////////////////////

2. Logical Modularity

 submodule


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it
exports: 


@NgModule({
    declarations: [GreeterComponent, HelloComponent, HaiComponent,WeclomeComponent],
    imports: [],
    providers: [],
    exports:[GreeterComponent]
})
export class GreeterModule {

}

barrel export:

- to reduce mutiple imports from the same folder
- to reduce file names from the import statement.

steps:

 greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts

import {Greeter} from './greeter/greeter.component'
import {Hai} from './greeter/hai.component'
import {Welcome} from './greeter/welcome.component'
 

greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts
    index.ts

index.js
   export *from './greeter.component'

///////////////////////////////////////////////////////////////////////////////////////////

Automation

ng g m header --module=app   
ng g c header  --flat=true --export=true --inline-style=true --inline-template--skip-tests=true   --module=header

..........................................................................................

Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding


1.interpolation:

MVC design pattern

Angular implements MVC design pattern.

M -Model data
V - View - Component Template
C - Controller - Component

COntroller transfer data to View.

Model- primitives,objects, arrays

interpolation syntax:

 {{Variable}}

import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interpolation',
  templateUrl: './interpolation.component.html',
  styles: [
  ]
})
export class InterpolationComponent implements OnInit {

  ///data : model
  //string
  firstName: string = "Subramanian"
  lastName = "Murugan";

  //numbers
  salary: number = 1000;
  tax = 10;

  //booleans
  status: boolean = true

  //object
  address: Address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu',
    doorno: 10
  }
  skills: Array<string> = ["JavaScript", "TypeScript", "Angular", "MicroServices"];



  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <div>
        <h2>Strings</h2>
        <p>Name {{firstName}} {{lastName}}</p>
    </div>
    <h2>Numbers</h2>
    <div>
        <p>Salary {{salary}} Tax {{tax}}</p>
    </div>
    <h2>Boolean</h2>
    <div>
        <p>Status {{status ? "Available" : "Not Available"}}</p>
    </div>
    <div>
        <h2>Object</h2>
        <address>
            {{address.doorno}} {{address.city}} {{address.state}}
        </address>
    </div>
    <h2>Arrays</h2>
    <div>
        <ul>
            <li *ngFor="let skill of skills">{{skill}}</li>
        </ul>
    </div>
</div>

///////////////////////////////////////////////////////////////////////////////////////////

Property:[]

attribute and property are synonmous

attribute means "property of html elements"
property means  "property of custom elements"

Where ever you [], you can understand that the element can have dynamic values


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attribute',
  templateUrl: './attribute.component.html',
  styles: [
  ]
})
export class AttributeComponent implements OnInit {
  imageUrl="favicon.ico"
  isEnabled:boolean = true
  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <h2>Static Image</h2>
    <img src="favicon.ico">
    <h2>Dynamic Image: Getting Image From Code</h2>
    <img [src]="imageUrl">
    <div>
        <button [disabled]="isEnabled">Show Me</button>
    </div>
</div>
///////////////////////////////////////////////////////////////////////////////////////////////

Custom Elements and Property Binding?

-passing data to component dynamically.

<div>
  <h1>Data Binding: Interpolation</h1>
  <app-interpolation></app-interpolation>
  <hr>
  <h1>Data Binding: AttributeBinding</h1>
  <app-attribute></app-attribute>
  <hr>
  <h1>Data Binding: Property Binding</h1>
  <app-greeterprop [message]="message" [name]="'Subramanian'" ></app-greeterprop>
  <app-greeterprop [message]="'Welcome'" [name]="'ram'"  ></app-greeterprop>
  <app-greeterprop [message]="'Greeter'" [name]="'karthik'"  ></app-greeterprop>

</div>

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  message:string = "Hello,How are you?"
}
.................
import { Component, OnInit,Input } from '@angular/core';

@Component({
  selector: 'app-greeterprop',
  templateUrl: './greeterprop.component.html',
  styles: [
  ]
})
export class GreeterpropComponent implements OnInit {

  //place holder variable; used to read value which was sent by parent component

  @Input()
  message:string=""
  @Input("name")
  myname:string=""

  constructor() { }

  ngOnInit(): void {
  }

}

<div>
    <h2>Value From App {{message}} {{myname}}</h2>
</div>

//////////////////////////////////////////////////////////////////////////////////////////

Container and Presentational Components:

Container components are reponsible for holding data.

Presentational components are just display the data,

///////////////////////////////////////////////////////////////////////////////////////////

Interaction with UI: Event Binding: ()

DOM events:

<button (click)="listner" >Click</button>

EventTarget Object:
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way data binding:
when ever data is transfered from the ui , controller is notified, whenever controller updates the data,ui is notified

Two way data binding is achvied via 

 $event ----instance variable

.............................................................................................

<div>
    <h2>Click Event</h2>
    <button (click)="onClick()">Click</button>
</div>
<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{inputMessage}}</h3>
        <input (input)="onRead($event)">
    </div>
    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>

    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>

</div>

............................................................................................

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dom-event-binding',
  templateUrl: './dom-event-binding.component.html',
  styles: [
  ]
})
export class DomEventBindingComponent implements OnInit {

  inputMessage: string = "..."

  messageOne:string="....";

  messageTwo:string="....";

  messageThree:string="....";

  constructor() { }

  onClick() {
    alert('Button was clicked')
  }
  onRead(evt: any) {
    //  console.log(evt.target.value)
    this.inputMessage = evt.target.value
  }
  ngOnInit(): void {
  }

}
//////////////////////////////////////////////////////////////////////////////////////////////

Component Communcation:

 Why component need to communicate?

data transfer

- parent to child  - props pattern
- child to parent --- event emitter pattern.
- sibilings  ---- services-rxjs


EventEmitter is Rxjs Implmentation:

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}

















