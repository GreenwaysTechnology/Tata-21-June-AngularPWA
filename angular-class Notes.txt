@angular - @ means private npm package

@angular/core

<app-root></app-root> -----| custom element
           |
           -------------------|main.js-----app.module.js----app.component.js

			      main.ts------app.module.ts----app.component.ts


main method

Angular supports lot of built in decorators.

 Component ContentChild ContentChildren Directive Host HostBinding HostListener Inject Injectable Input NgModule Optional Output Pipe Self SkipSelf ViewChild ViewChildren

component

-declare class
-decorator - decorate class makes corresponding object.

component

- class 

-decorator
  is function
  takes args - decorator meta data
  meta data - is object in angular


Template:

 - inline template -  as part of component

 - external template  separate file and linked

@Component({
  selector: 'app-root', // tag name
  // template: `
  //     <h1>Tata Technologies </h1>  
  // `
  templateUrl: './app.component.html'
})
export class AppComponent {

}


//
object creations

 let app = new AppComponent()

in angular we dont create infra objects- angular create automatically.

   injector system.


Depedency injection

- automation
 object creation
    +
 refer created object inside object  

how to tell angular to create objects.

Angular never creates objects until you tell -  you configure.

Angular creates infra objects only. via decorator.

Even though angular uses infra objects, never creates them until you tell.

Where you can tell?

 inside another object called "Module" - AppModule.


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
/////////////////////////////////////////////////////////////////////////////////////////////

Coding Best practice:

<app-root>
  ? - ?
  
file names:

domainname.component/service/directive/pipe/module /.spec.ts/html/css

hero.component.ts|html|css|spec
hero.service.ts
hero.directive.ts

hero.component.ts
hero.component.css
hero.component.html

tag name:
Do use dashed-case or kebab-case for naming the element selectors of components.

app-hero  : dash case / kekab-case

class Names

-Do use upper camel case for class names.
-Do match the name of the symbol to the name of the file.
-Do append the symbol name with the conventional suffix x (such as Component, Directive, Module, Pipe, or Service) for a thing of that type.
   CustomerComponent, CustomerService, CustomerDirective CustomerPipe ..

Do give the filename the conventional suffix (such as .component.ts, .directive.ts, .module.ts, .pipe.ts, or .service.ts) for a file of that type.

   customer.component.ts    ----export class CustomerComponent { }
   customer.module.ts
   customer.pipe.ts
   etc...

modularaization:

1.break app into files and folders

app - main folder -  only root files - module,component
 |
 greeter
 customer
 product
 utils
 services
 directives
 pipes

Component driven arch:

 as much as possible we have break component ; 


Angular dev tool

///////////////////////////////////////////////////////////////////////////////////////////

2. Logical Modularity

 submodule


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it
exports: 


@NgModule({
    declarations: [GreeterComponent, HelloComponent, HaiComponent,WeclomeComponent],
    imports: [],
    providers: [],
    exports:[GreeterComponent]
})
export class GreeterModule {

}

barrel export:

- to reduce mutiple imports from the same folder
- to reduce file names from the import statement.

steps:

 greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts

import {Greeter} from './greeter/greeter.component'
import {Hai} from './greeter/hai.component'
import {Welcome} from './greeter/welcome.component'
 

greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts
    index.ts

index.js
   export *from './greeter.component'

///////////////////////////////////////////////////////////////////////////////////////////

Automation

ng g m header --module=app   
ng g c header  --flat=true --export=true --inline-style=true --inline-template--skip-tests=true   --module=header

..........................................................................................

Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding


1.interpolation:

MVC design pattern

Angular implements MVC design pattern.

M -Model data
V - View - Component Template
C - Controller - Component

COntroller transfer data to View.

Model- primitives,objects, arrays

interpolation syntax:

 {{Variable}}

import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interpolation',
  templateUrl: './interpolation.component.html',
  styles: [
  ]
})
export class InterpolationComponent implements OnInit {

  ///data : model
  //string
  firstName: string = "Subramanian"
  lastName = "Murugan";

  //numbers
  salary: number = 1000;
  tax = 10;

  //booleans
  status: boolean = true

  //object
  address: Address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu',
    doorno: 10
  }
  skills: Array<string> = ["JavaScript", "TypeScript", "Angular", "MicroServices"];



  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <div>
        <h2>Strings</h2>
        <p>Name {{firstName}} {{lastName}}</p>
    </div>
    <h2>Numbers</h2>
    <div>
        <p>Salary {{salary}} Tax {{tax}}</p>
    </div>
    <h2>Boolean</h2>
    <div>
        <p>Status {{status ? "Available" : "Not Available"}}</p>
    </div>
    <div>
        <h2>Object</h2>
        <address>
            {{address.doorno}} {{address.city}} {{address.state}}
        </address>
    </div>
    <h2>Arrays</h2>
    <div>
        <ul>
            <li *ngFor="let skill of skills">{{skill}}</li>
        </ul>
    </div>
</div>

///////////////////////////////////////////////////////////////////////////////////////////

Property:[]

attribute and property are synonmous

attribute means "property of html elements"
property means  "property of custom elements"

Where ever you [], you can understand that the element can have dynamic values


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attribute',
  templateUrl: './attribute.component.html',
  styles: [
  ]
})
export class AttributeComponent implements OnInit {
  imageUrl="favicon.ico"
  isEnabled:boolean = true
  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <h2>Static Image</h2>
    <img src="favicon.ico">
    <h2>Dynamic Image: Getting Image From Code</h2>
    <img [src]="imageUrl">
    <div>
        <button [disabled]="isEnabled">Show Me</button>
    </div>
</div>
///////////////////////////////////////////////////////////////////////////////////////////////

Custom Elements and Property Binding?

-passing data to component dynamically.

<div>
  <h1>Data Binding: Interpolation</h1>
  <app-interpolation></app-interpolation>
  <hr>
  <h1>Data Binding: AttributeBinding</h1>
  <app-attribute></app-attribute>
  <hr>
  <h1>Data Binding: Property Binding</h1>
  <app-greeterprop [message]="message" [name]="'Subramanian'" ></app-greeterprop>
  <app-greeterprop [message]="'Welcome'" [name]="'ram'"  ></app-greeterprop>
  <app-greeterprop [message]="'Greeter'" [name]="'karthik'"  ></app-greeterprop>

</div>

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  message:string = "Hello,How are you?"
}
.................
import { Component, OnInit,Input } from '@angular/core';

@Component({
  selector: 'app-greeterprop',
  templateUrl: './greeterprop.component.html',
  styles: [
  ]
})
export class GreeterpropComponent implements OnInit {

  //place holder variable; used to read value which was sent by parent component

  @Input()
  message:string=""
  @Input("name")
  myname:string=""

  constructor() { }

  ngOnInit(): void {
  }

}

<div>
    <h2>Value From App {{message}} {{myname}}</h2>
</div>

//////////////////////////////////////////////////////////////////////////////////////////

Container and Presentational Components:

Container components are reponsible for holding data.

Presentational components are just display the data,

///////////////////////////////////////////////////////////////////////////////////////////

Interaction with UI: Event Binding: ()

DOM events:

<button (click)="listner" >Click</button>

EventTarget Object:
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way data binding:
when ever data is transfered from the ui , controller is notified, whenever controller updates the data,ui is notified

Two way data binding is achvied via 

 $event ----instance variable

.............................................................................................

<div>
    <h2>Click Event</h2>
    <button (click)="onClick()">Click</button>
</div>
<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{inputMessage}}</h3>
        <input (input)="onRead($event)">
    </div>
    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>

    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>

</div>

............................................................................................

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dom-event-binding',
  templateUrl: './dom-event-binding.component.html',
  styles: [
  ]
})
export class DomEventBindingComponent implements OnInit {

  inputMessage: string = "..."

  messageOne:string="....";

  messageTwo:string="....";

  messageThree:string="....";

  constructor() { }

  onClick() {
    alert('Button was clicked')
  }
  onRead(evt: any) {
    //  console.log(evt.target.value)
    this.inputMessage = evt.target.value
  }
  ngOnInit(): void {
  }

}
//////////////////////////////////////////////////////////////////////////////////////////////

Component Communcation:

 Why component need to communicate?

data transfer

- parent to child  - props pattern
- child to parent --- event emitter pattern.
- sibilings  ---- services-rxjs


EventEmitter is Rxjs Implmentation:

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}
/////////////////////////////////////////////////////////////////////////////////////////////

					Styling
/////////////////////////////////////////////////////////////////////////////////////////////

Styling done through css:

1.inline css using style attribute
2.external css using class attribute

How to add css into angular ?

1.global css

app css
 styles.css
via thrid party- like bootstrap,material


2.inside component 
  


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dynamicstyle',
  template: `
    <h1 style="text-align: center;"> Styles </h1>

    <div [class.card]="isActive">
              <p [style.text-decoration]="activeLinkStyle" >Hello</p>
     </div>
    <button (click)="changeStyle()">Apply Color</button>
  `,
  styles: [
  ]
})
export class DynamicstyleComponent implements OnInit {
  isActive: boolean = false
  activeLinkStyle='overline'
  changeStyle() {
    this.isActive = !this.isActive
  }
  constructor() { }

  ngOnInit(): void {
  }

}
////////////////////////////////////////////////////////////////////////////////////////////
					pipes


<h1>Pipes </h1>
<div>
    <h2>Date</h2>
    <h3>Today {{today | date}}</h3>
    <h3>Today {{today | date:'dd/MM/yyyy'}}</h3>

</div>
<div>
<h2>Currency Pipe</h2>
    <p>A: {{a | currency}}</p>

    <p>A: {{a | currency:'INR'}}</p>

    <!--output 'CA$0.26'-->
    <p>A: {{a | currency:'CAD'}}</p>

    <!--output 'CAD0.26'-->
    <p>A: {{a | currency:'CAD':'code'}}</p>

    <!--output 'CA$0,001.35'-->
    <p>B: {{b | currency:'CAD':'symbol':'4.2-2'}}</p>

    <!--output '$0,001.35'-->
    <p>B: {{b | currency:'CAD':'symbol-narrow':'4.2-2'}}</p>

    <!--output '0 001,35 CA$'-->
    <p>B: {{b | currency:'CAD':'symbol':'4.2-2':'fr'}}</p>

    <!--output 'CLP1' because CLP has no cents-->
    <p>B: {{b | currency:'CLP'}}</p>

</div>
<div>
    <h2>String Pipe</h2>
    <h3>Name {{name | uppercase}}</h3>    
    <h3>Name {{name | lowercase}}</h3>
    <h3>Name {{name | titlecase}}</h3>
</div>
<div>
    <h2>Percentage(%) Pipe</h2>
    <h3>How much percent {{a | percent}}</h3>    
 </div>

 <div>
    <h2>JSON pipe</h2>
    <h3>{{user | json}}</h3>    
 </div>

 <div>
     <h2>Chaining Pipes</h2>
     <h3>Today :  {{today | date:'fullDate' | uppercase }}</h3>
 </div>
 <hr>
 <div>
     <h2>Custom Pipes</h2>
     <h3>Power of {{power}} is {{power | power:2}}</h3>
 </div>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-pipes',
  templateUrl: './pipes.component.html',
  styles: [
  ]
})
export class PipesComponent implements OnInit {

  today = new Date()
  a: number = 0.345
  b: number = 1.3456
  name: string = "subramanian"

  user = {
    id: 1,
    name: 'Subramaian',
    skills: ['javascript', 'angular', 'microservices']
  }
  power: number = 10
  constructor() { }

  ngOnInit(): void {
  }

}


import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'power'
})
export class PowerPipe implements PipeTransform {
  transform(value: number, exponent: number = 1): number {
    return Math.pow(value, exponent)
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////	
					Directives
/////////////////////////////////////////////////////////////////////////////////////////////

What is directive?

 Directives are classes that add additional behaviour to elements in angular apps.
In General directives are custom elements or attributes.


Types of Directives

1.Template Directive
2.Structural directive
3.Attribute Directive



1.Template Directive:
  Directive with templates. Components.
  Create Custom elements

2.Structrual Directive
   are directives which change dom layout -  adding or removing dom elements.
  Create and delete dom elements

Types of Structural Directives

1.NgIf ---class ------ *ngIf
  if...else logic 
  conditionally creates or removes of subviews from the template.

2.NgFor----class -----*ngFor
    repeat a node for each item in a list

3.NgSwitch---class ---*ngSwitch
    a set of directives that switch among alternative views.


 
*ngIf:
<div>
    <h1>If Condtion</h1>
    <div *ngIf="isHidden" >
        <h2>Hey How are you</h2>
    </div>
    <button (click)="show()">Show/Hide</button>
</div>

export class StructuraldirectiveComponent implements OnInit {
  isHidden: boolean = true;
  constructor() { }

  ngOnInit(): void {
  }
  show(){
    this.isHidden = !this.isHidden
  }

}

if i want to implement show/hide use case , dont use *ngIF
 - dynamically remove and add gives performance issues.

<div [hidden]=>

</div>

<div>
    <h1>If Condtion</h1>
    <div *ngIf="isHidden">
        <h2>Hey How are you</h2>
    </div>
    <button (click)="show()">Show/Hide</button>
</div>

<div>
    <h1>Using Hidden attribute</h1>
    <div [hidden]="isShown">
        <h2>Hey How are you</h2>
    </div>
    <button (click)="showHidden()">Show/Hide</button>
</div>

<div>
    <h1>if..else</h1>
    <div *ngIf="isAvailable; else mycondition">
        <h1>You have Facility!</h1>
    </div>
    <ng-template #mycondition>
        <h1>Sorry! Facility is not availbale</h1>
    </ng-template>
    <button (click)="isFacilityAvailable()">Show Facility</button>
</div>

<div>
    <h1>Progress Bar using if..else</h1>
    <h2>
        <div *ngIf="loading; else notLoading  ">
            <h2>{{status}}</h2>
        </div>
    </h2>
    <ng-template #notLoading>
        <div>
            <h2>{{status}}</h2>
        </div>
    </ng-template>
</div>

<div>
    <h1 style="text-align: center;">Swich case </h1>
    <input [(ngModel)]="input">
    <button (click)="showFeedback()">Show Feedback</button>

    <div [ngSwitch]="feedback">
        <p *ngSwitchCase="'good'">Good</p>
        <p *ngSwitchCase="'verygood'">Very Good</p>
        <p *ngSwitchCase="'bad'">Bad</p>
        <p *ngSwitchDefault>Your input is not matching</p>
    </div>
    <div [ngSwitch]="feedback">
        <ng-template [ngSwitchCase]="'good'">
            <h3>Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'verygood'">
            <h3>Very Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'bad'">
            <h3>bad</h3>
        </ng-template>
        <ng-template ngSwitchDefault>
            <h3>Your input is not matching</h3>
        </ng-template>
    </div>
</div>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-structuraldirective',
  templateUrl: './structuraldirective.component.html',
  styles: [
  ]
})
export class StructuraldirectiveComponent implements OnInit {
  isHidden: boolean = true;
  isShown: boolean = true;
  isAvailable: boolean = true;
  loading: boolean = true;
  status: string = "loading....."
  input: string = ""
  feedback: string = ""
  constructor() {
    setTimeout(() => {
      this.loading = !this.loading;
      this.status = "Response is Ready"
    }, 5000)

  }

  ngOnInit(): void {
  }
  show() {
    this.isHidden = !this.isHidden
  }
  showHidden() {
    this.isShown = !this.isShown
  }
  isFacilityAvailable() {
    this.isAvailable = !this.isAvailable
  }
  showFeedback() {
    this.feedback = this.input;
  }

}
.....................................................................................

*ngFor -  loops
........................................................................................
				 Attribute Directives
......................................................................................

<div>

    <h1>Attribute Directives</h1>
    <div>
        <input type="radio" name="colors" (click)="color='lightgreen'">Green
        <input type="radio" name="colors" (click)="color='cyan'">cyan
        <input type="radio" name="colors" (click)="color='yellow'">yellow
    </div>

    <h1 [appHighlight]="color">High Light Me!!!</h1>
    <!-- <p appHighlight>Attribute Directive</p> -->
    
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attributedirective',
  templateUrl: './attributedirective.component.html',
  styles: [
  ]
})
export class AttributedirectiveComponent implements OnInit {
  color:string = 'blue'
  constructor() { }

  ngOnInit(): void {
  }

}


import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  @Input()
  appHighlight=''

  constructor(private element:ElementRef) { 
    console.log(element)
    console.log(this.element.nativeElement)
   // this.element.nativeElement.style.backgroundColor='yellow'
  }
  //attach events
  @HostListener('mouseenter')
  public onMouseEnter(){
      this.highlight(this.appHighlight)
  }
  @HostListener('mouseleave')
  public onMouseLeave(){
    this.highlight('')

  }
  private highlight(color:string){
    this.element.nativeElement.style.backgroundColor=color;

  }

}

/////////////////////////////////////////////////////////////////////////////////////////////
                                  Template Reference Variable
//////////////////////////////////////////////////////////////////////////////////////////////

Getting DOM Reference inside template itself -Template Reference variable.

DOM Manipulation in angular patterns:

Within comonent/directive code - inside ts code
1.Via $event Object.
2.Via Attribute Directive : ElementRef,@HostListener.
3.Via structural directive

inside template itself:

4.Template Reference Variable : #
 To access dom objects inside /across templates.

DOM Manipulation in angular patterns:


Within comonent/directive code - inside ts code
1.Via $event Object.
2.Via Attribute Directive : ElementRef,@HostListener.
3.Via structural directive

inside template itself:

4.Template Reference Variable : #
 To access dom objects inside /across templates.


<div>
    <h1 style="text-align: center;">Template Reference</h1>

    <div>
        <h1>Name : {{firstname}}</h1>
        <input #name placeholder="Please Enter Your Name">

        <button class="btn btn-success" (click)="setName(name.value)">Get Value From Template</button>
    </div>
</div>
export class TemplatereferenceComponent implements OnInit {

  color:string = 'red'
  firstname:string ='Default'

  public setName(name:string){
     this.firstname = name;
  }
  constructor() { }

  ngOnInit(): void {
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////






















