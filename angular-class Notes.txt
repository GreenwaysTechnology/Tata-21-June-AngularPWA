@angular - @ means private npm package

@angular/core

<app-root></app-root> -----| custom element
           |
           -------------------|main.js-----app.module.js----app.component.js

			      main.ts------app.module.ts----app.component.ts


main method

Angular supports lot of built in decorators.

 Component ContentChild ContentChildren Directive Host HostBinding HostListener Inject Injectable Input NgModule Optional Output Pipe Self SkipSelf ViewChild ViewChildren

component

-declare class
-decorator - decorate class makes corresponding object.

component

- class 

-decorator
  is function
  takes args - decorator meta data
  meta data - is object in angular


Template:

 - inline template -  as part of component

 - external template  separate file and linked

@Component({
  selector: 'app-root', // tag name
  // template: `
  //     <h1>Tata Technologies </h1>  
  // `
  templateUrl: './app.component.html'
})
export class AppComponent {

}


//
object creations

 let app = new AppComponent()

in angular we dont create infra objects- angular create automatically.

   injector system.


Depedency injection

- automation
 object creation
    +
 refer created object inside object  

how to tell angular to create objects.

Angular never creates objects until you tell -  you configure.

Angular creates infra objects only. via decorator.

Even though angular uses infra objects, never creates them until you tell.

Where you can tell?

 inside another object called "Module" - AppModule.


import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
/////////////////////////////////////////////////////////////////////////////////////////////

Coding Best practice:

<app-root>
  ? - ?
  
file names:

domainname.component/service/directive/pipe/module /.spec.ts/html/css

hero.component.ts|html|css|spec
hero.service.ts
hero.directive.ts

hero.component.ts
hero.component.css
hero.component.html

tag name:
Do use dashed-case or kebab-case for naming the element selectors of components.

app-hero  : dash case / kekab-case

class Names

-Do use upper camel case for class names.
-Do match the name of the symbol to the name of the file.
-Do append the symbol name with the conventional suffix x (such as Component, Directive, Module, Pipe, or Service) for a thing of that type.
   CustomerComponent, CustomerService, CustomerDirective CustomerPipe ..

Do give the filename the conventional suffix (such as .component.ts, .directive.ts, .module.ts, .pipe.ts, or .service.ts) for a file of that type.

   customer.component.ts    ----export class CustomerComponent { }
   customer.module.ts
   customer.pipe.ts
   etc...

modularaization:

1.break app into files and folders

app - main folder -  only root files - module,component
 |
 greeter
 customer
 product
 utils
 services
 directives
 pipes

Component driven arch:

 as much as possible we have break component ; 


Angular dev tool

///////////////////////////////////////////////////////////////////////////////////////////

2. Logical Modularity

 submodule


Module Scope:

1.public scope
   if any objects belong to all modules that  is public
2.private scope
  if any objects belong to that module is private including appmodule.

if you want to make any object in public scope, you need to configer it
exports: 


@NgModule({
    declarations: [GreeterComponent, HelloComponent, HaiComponent,WeclomeComponent],
    imports: [],
    providers: [],
    exports:[GreeterComponent]
})
export class GreeterModule {

}

barrel export:

- to reduce mutiple imports from the same folder
- to reduce file names from the import statement.

steps:

 greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts

import {Greeter} from './greeter/greeter.component'
import {Hai} from './greeter/hai.component'
import {Welcome} from './greeter/welcome.component'
 

greeter
    hai.component.ts
    greeter.component.ts
    welcome.component.ts
    index.ts

index.js
   export *from './greeter.component'

///////////////////////////////////////////////////////////////////////////////////////////

Automation

ng g m header --module=app   
ng g c header  --flat=true --export=true --inline-style=true --inline-template--skip-tests=true   --module=header

..........................................................................................

Data binding:
 Transfering state to ui(view)

Types of databinding

1.interpolation
2.property binding
3.attribute binding
4.event binding
5.two way data binding
6.class binding
7.style binding


1.interpolation:

MVC design pattern

Angular implements MVC design pattern.

M -Model data
V - View - Component Template
C - Controller - Component

COntroller transfer data to View.

Model- primitives,objects, arrays

interpolation syntax:

 {{Variable}}

import { Component, OnInit } from '@angular/core';
import { Address } from '../types/address.type';

@Component({
  selector: 'app-interpolation',
  templateUrl: './interpolation.component.html',
  styles: [
  ]
})
export class InterpolationComponent implements OnInit {

  ///data : model
  //string
  firstName: string = "Subramanian"
  lastName = "Murugan";

  //numbers
  salary: number = 1000;
  tax = 10;

  //booleans
  status: boolean = true

  //object
  address: Address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu',
    doorno: 10
  }
  skills: Array<string> = ["JavaScript", "TypeScript", "Angular", "MicroServices"];



  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <div>
        <h2>Strings</h2>
        <p>Name {{firstName}} {{lastName}}</p>
    </div>
    <h2>Numbers</h2>
    <div>
        <p>Salary {{salary}} Tax {{tax}}</p>
    </div>
    <h2>Boolean</h2>
    <div>
        <p>Status {{status ? "Available" : "Not Available"}}</p>
    </div>
    <div>
        <h2>Object</h2>
        <address>
            {{address.doorno}} {{address.city}} {{address.state}}
        </address>
    </div>
    <h2>Arrays</h2>
    <div>
        <ul>
            <li *ngFor="let skill of skills">{{skill}}</li>
        </ul>
    </div>
</div>

///////////////////////////////////////////////////////////////////////////////////////////

Property:[]

attribute and property are synonmous

attribute means "property of html elements"
property means  "property of custom elements"

Where ever you [], you can understand that the element can have dynamic values


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attribute',
  templateUrl: './attribute.component.html',
  styles: [
  ]
})
export class AttributeComponent implements OnInit {
  imageUrl="favicon.ico"
  isEnabled:boolean = true
  constructor() { }

  ngOnInit(): void {
  }

}
<div>
    <h2>Static Image</h2>
    <img src="favicon.ico">
    <h2>Dynamic Image: Getting Image From Code</h2>
    <img [src]="imageUrl">
    <div>
        <button [disabled]="isEnabled">Show Me</button>
    </div>
</div>
///////////////////////////////////////////////////////////////////////////////////////////////

Custom Elements and Property Binding?

-passing data to component dynamically.

<div>
  <h1>Data Binding: Interpolation</h1>
  <app-interpolation></app-interpolation>
  <hr>
  <h1>Data Binding: AttributeBinding</h1>
  <app-attribute></app-attribute>
  <hr>
  <h1>Data Binding: Property Binding</h1>
  <app-greeterprop [message]="message" [name]="'Subramanian'" ></app-greeterprop>
  <app-greeterprop [message]="'Welcome'" [name]="'ram'"  ></app-greeterprop>
  <app-greeterprop [message]="'Greeter'" [name]="'karthik'"  ></app-greeterprop>

</div>

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  message:string = "Hello,How are you?"
}
.................
import { Component, OnInit,Input } from '@angular/core';

@Component({
  selector: 'app-greeterprop',
  templateUrl: './greeterprop.component.html',
  styles: [
  ]
})
export class GreeterpropComponent implements OnInit {

  //place holder variable; used to read value which was sent by parent component

  @Input()
  message:string=""
  @Input("name")
  myname:string=""

  constructor() { }

  ngOnInit(): void {
  }

}

<div>
    <h2>Value From App {{message}} {{myname}}</h2>
</div>

//////////////////////////////////////////////////////////////////////////////////////////

Container and Presentational Components:

Container components are reponsible for holding data.

Presentational components are just display the data,

///////////////////////////////////////////////////////////////////////////////////////////

Interaction with UI: Event Binding: ()

DOM events:

<button (click)="listner" >Click</button>

EventTarget Object:
  It connects dom object and listner method.
  where listener method can read values and other proproperties of dom object.

btn.addEventListener = function(evt){
   

}
$event  - is global variable from the angular which has reference of EventTarget object


Two way data binding:
when ever data is transfered from the ui , controller is notified, whenever controller updates the data,ui is notified

Two way data binding is achvied via 

 $event ----instance variable

.............................................................................................

<div>
    <h2>Click Event</h2>
    <button (click)="onClick()">Click</button>
</div>
<div>
    <h2>Input Event</h2>
    <div>
        <h3>With Listener</h3>
        <h3>{{inputMessage}}</h3>
        <input (input)="onRead($event)">
    </div>
    <div>
        <h3>Without Listener</h3>
        <h3>{{messageOne}}</h3>
        <input (input)="messageOne=$event.target.value">
    </div>

    <div>
        <h3>Property Binding + Event Binding </h3>
        <h3>{{messageTwo}}</h3>
        <input  [value]="messageTwo" (input)="messageTwo=$event.target.value">
    </div>
    <div>
        <h3>Property Binding + Event Binding = Banana Box Notation [()] </h3>
        <h3>{{messageThree}}</h3>
        <input [(ngModel)]="messageThree">
    </div>

</div>

............................................................................................

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dom-event-binding',
  templateUrl: './dom-event-binding.component.html',
  styles: [
  ]
})
export class DomEventBindingComponent implements OnInit {

  inputMessage: string = "..."

  messageOne:string="....";

  messageTwo:string="....";

  messageThree:string="....";

  constructor() { }

  onClick() {
    alert('Button was clicked')
  }
  onRead(evt: any) {
    //  console.log(evt.target.value)
    this.inputMessage = evt.target.value
  }
  ngOnInit(): void {
  }

}
//////////////////////////////////////////////////////////////////////////////////////////////

Component Communcation:

 Why component need to communicate?

data transfer

- parent to child  - props pattern
- child to parent --- event emitter pattern.
- sibilings  ---- services-rxjs


EventEmitter is Rxjs Implmentation:

class EventEmitter<T> extends Subject {
  constructor(isAsync?: boolean): EventEmitter<T>
  emit(value?: T): void
  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription
}
/////////////////////////////////////////////////////////////////////////////////////////////

					Styling
/////////////////////////////////////////////////////////////////////////////////////////////

Styling done through css:

1.inline css using style attribute
2.external css using class attribute

How to add css into angular ?

1.global css

app css
 styles.css
via thrid party- like bootstrap,material


2.inside component 
  


import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dynamicstyle',
  template: `
    <h1 style="text-align: center;"> Styles </h1>

    <div [class.card]="isActive">
              <p [style.text-decoration]="activeLinkStyle" >Hello</p>
     </div>
    <button (click)="changeStyle()">Apply Color</button>
  `,
  styles: [
  ]
})
export class DynamicstyleComponent implements OnInit {
  isActive: boolean = false
  activeLinkStyle='overline'
  changeStyle() {
    this.isActive = !this.isActive
  }
  constructor() { }

  ngOnInit(): void {
  }

}
////////////////////////////////////////////////////////////////////////////////////////////
					pipes


<h1>Pipes </h1>
<div>
    <h2>Date</h2>
    <h3>Today {{today | date}}</h3>
    <h3>Today {{today | date:'dd/MM/yyyy'}}</h3>

</div>
<div>
<h2>Currency Pipe</h2>
    <p>A: {{a | currency}}</p>

    <p>A: {{a | currency:'INR'}}</p>

    <!--output 'CA$0.26'-->
    <p>A: {{a | currency:'CAD'}}</p>

    <!--output 'CAD0.26'-->
    <p>A: {{a | currency:'CAD':'code'}}</p>

    <!--output 'CA$0,001.35'-->
    <p>B: {{b | currency:'CAD':'symbol':'4.2-2'}}</p>

    <!--output '$0,001.35'-->
    <p>B: {{b | currency:'CAD':'symbol-narrow':'4.2-2'}}</p>

    <!--output '0 001,35 CA$'-->
    <p>B: {{b | currency:'CAD':'symbol':'4.2-2':'fr'}}</p>

    <!--output 'CLP1' because CLP has no cents-->
    <p>B: {{b | currency:'CLP'}}</p>

</div>
<div>
    <h2>String Pipe</h2>
    <h3>Name {{name | uppercase}}</h3>    
    <h3>Name {{name | lowercase}}</h3>
    <h3>Name {{name | titlecase}}</h3>
</div>
<div>
    <h2>Percentage(%) Pipe</h2>
    <h3>How much percent {{a | percent}}</h3>    
 </div>

 <div>
    <h2>JSON pipe</h2>
    <h3>{{user | json}}</h3>    
 </div>

 <div>
     <h2>Chaining Pipes</h2>
     <h3>Today :  {{today | date:'fullDate' | uppercase }}</h3>
 </div>
 <hr>
 <div>
     <h2>Custom Pipes</h2>
     <h3>Power of {{power}} is {{power | power:2}}</h3>
 </div>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-pipes',
  templateUrl: './pipes.component.html',
  styles: [
  ]
})
export class PipesComponent implements OnInit {

  today = new Date()
  a: number = 0.345
  b: number = 1.3456
  name: string = "subramanian"

  user = {
    id: 1,
    name: 'Subramaian',
    skills: ['javascript', 'angular', 'microservices']
  }
  power: number = 10
  constructor() { }

  ngOnInit(): void {
  }

}


import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'power'
})
export class PowerPipe implements PipeTransform {
  transform(value: number, exponent: number = 1): number {
    return Math.pow(value, exponent)
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////	
					Directives
/////////////////////////////////////////////////////////////////////////////////////////////

What is directive?

 Directives are classes that add additional behaviour to elements in angular apps.
In General directives are custom elements or attributes.


Types of Directives

1.Template Directive
2.Structural directive
3.Attribute Directive



1.Template Directive:
  Directive with templates. Components.
  Create Custom elements

2.Structrual Directive
   are directives which change dom layout -  adding or removing dom elements.
  Create and delete dom elements

Types of Structural Directives

1.NgIf ---class ------ *ngIf
  if...else logic 
  conditionally creates or removes of subviews from the template.

2.NgFor----class -----*ngFor
    repeat a node for each item in a list

3.NgSwitch---class ---*ngSwitch
    a set of directives that switch among alternative views.


 
*ngIf:
<div>
    <h1>If Condtion</h1>
    <div *ngIf="isHidden" >
        <h2>Hey How are you</h2>
    </div>
    <button (click)="show()">Show/Hide</button>
</div>

export class StructuraldirectiveComponent implements OnInit {
  isHidden: boolean = true;
  constructor() { }

  ngOnInit(): void {
  }
  show(){
    this.isHidden = !this.isHidden
  }

}

if i want to implement show/hide use case , dont use *ngIF
 - dynamically remove and add gives performance issues.

<div [hidden]=>

</div>

<div>
    <h1>If Condtion</h1>
    <div *ngIf="isHidden">
        <h2>Hey How are you</h2>
    </div>
    <button (click)="show()">Show/Hide</button>
</div>

<div>
    <h1>Using Hidden attribute</h1>
    <div [hidden]="isShown">
        <h2>Hey How are you</h2>
    </div>
    <button (click)="showHidden()">Show/Hide</button>
</div>

<div>
    <h1>if..else</h1>
    <div *ngIf="isAvailable; else mycondition">
        <h1>You have Facility!</h1>
    </div>
    <ng-template #mycondition>
        <h1>Sorry! Facility is not availbale</h1>
    </ng-template>
    <button (click)="isFacilityAvailable()">Show Facility</button>
</div>

<div>
    <h1>Progress Bar using if..else</h1>
    <h2>
        <div *ngIf="loading; else notLoading  ">
            <h2>{{status}}</h2>
        </div>
    </h2>
    <ng-template #notLoading>
        <div>
            <h2>{{status}}</h2>
        </div>
    </ng-template>
</div>

<div>
    <h1 style="text-align: center;">Swich case </h1>
    <input [(ngModel)]="input">
    <button (click)="showFeedback()">Show Feedback</button>

    <div [ngSwitch]="feedback">
        <p *ngSwitchCase="'good'">Good</p>
        <p *ngSwitchCase="'verygood'">Very Good</p>
        <p *ngSwitchCase="'bad'">Bad</p>
        <p *ngSwitchDefault>Your input is not matching</p>
    </div>
    <div [ngSwitch]="feedback">
        <ng-template [ngSwitchCase]="'good'">
            <h3>Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'verygood'">
            <h3>Very Good</h3>
        </ng-template>
        <ng-template [ngSwitchCase]="'bad'">
            <h3>bad</h3>
        </ng-template>
        <ng-template ngSwitchDefault>
            <h3>Your input is not matching</h3>
        </ng-template>
    </div>
</div>

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-structuraldirective',
  templateUrl: './structuraldirective.component.html',
  styles: [
  ]
})
export class StructuraldirectiveComponent implements OnInit {
  isHidden: boolean = true;
  isShown: boolean = true;
  isAvailable: boolean = true;
  loading: boolean = true;
  status: string = "loading....."
  input: string = ""
  feedback: string = ""
  constructor() {
    setTimeout(() => {
      this.loading = !this.loading;
      this.status = "Response is Ready"
    }, 5000)

  }

  ngOnInit(): void {
  }
  show() {
    this.isHidden = !this.isHidden
  }
  showHidden() {
    this.isShown = !this.isShown
  }
  isFacilityAvailable() {
    this.isAvailable = !this.isAvailable
  }
  showFeedback() {
    this.feedback = this.input;
  }

}
.....................................................................................

*ngFor -  loops
........................................................................................
				 Attribute Directives
......................................................................................

<div>

    <h1>Attribute Directives</h1>
    <div>
        <input type="radio" name="colors" (click)="color='lightgreen'">Green
        <input type="radio" name="colors" (click)="color='cyan'">cyan
        <input type="radio" name="colors" (click)="color='yellow'">yellow
    </div>

    <h1 [appHighlight]="color">High Light Me!!!</h1>
    <!-- <p appHighlight>Attribute Directive</p> -->
    
</div>
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-attributedirective',
  templateUrl: './attributedirective.component.html',
  styles: [
  ]
})
export class AttributedirectiveComponent implements OnInit {
  color:string = 'blue'
  constructor() { }

  ngOnInit(): void {
  }

}


import { Directive, ElementRef, HostListener, Input } from '@angular/core';

@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {

  @Input()
  appHighlight=''

  constructor(private element:ElementRef) { 
    console.log(element)
    console.log(this.element.nativeElement)
   // this.element.nativeElement.style.backgroundColor='yellow'
  }
  //attach events
  @HostListener('mouseenter')
  public onMouseEnter(){
      this.highlight(this.appHighlight)
  }
  @HostListener('mouseleave')
  public onMouseLeave(){
    this.highlight('')

  }
  private highlight(color:string){
    this.element.nativeElement.style.backgroundColor=color;

  }

}

/////////////////////////////////////////////////////////////////////////////////////////////
                                  Template Reference Variable
//////////////////////////////////////////////////////////////////////////////////////////////

Getting DOM Reference inside template itself -Template Reference variable.

DOM Manipulation in angular patterns:

Within comonent/directive code - inside ts code
1.Via $event Object.
2.Via Attribute Directive : ElementRef,@HostListener.
3.Via structural directive

inside template itself:

4.Template Reference Variable : #
 To access dom objects inside /across templates.

DOM Manipulation in angular patterns:


Within comonent/directive code - inside ts code
1.Via $event Object.
2.Via Attribute Directive : ElementRef,@HostListener.
3.Via structural directive

inside template itself:

4.Template Reference Variable : #
 To access dom objects inside /across templates.


<div>
    <h1 style="text-align: center;">Template Reference</h1>

    <div>
        <h1>Name : {{firstname}}</h1>
        <input #name placeholder="Please Enter Your Name">

        <button class="btn btn-success" (click)="setName(name.value)">Get Value From Template</button>
    </div>
</div>
export class TemplatereferenceComponent implements OnInit {

  color:string = 'red'
  firstname:string ='Default'

  public setName(name:string){
     this.firstname = name;
  }
  constructor() { }

  ngOnInit(): void {
  }

}
/////////////////////////////////////////////////////////////////////////////////////////////
                                 Forms
.............................................................................................

Types of forms

1.Template driven forms
2.Reactive Forms


Template driven Forms

Steps:

1.import formsModule where ever you create forms

import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

Step 2: create model object

export class Post {
    constructor(public id: number, public title: string, public author: string) { }
}

3.create basic form template: we have to use bootstrap form template syntax.
<div class="container">
  <h1>Forms -Template Driven </h1>
  <h1>Post Form</h1>
  <form>
    <div class="form-group">
      <label for="title">Title</label>
      <input type="text" class="form-control" id="title" required>
    </div>

    <div class="form-group">
      <label for="name">Name</label>
      <input type="text" class="form-control" id="name" required>
    </div>

    <button type="submit" class="btn btn-success">Submit</button>
  </form>
</div>

4.Model to form binding: data binding


4.1.create model object inside component
import { Component } from "@angular/core";
import { Post } from "./models/form.modle";


@Component({
    selector: 'app-post-form',
    templateUrl: 'postform.component.html'
})
export class PostFormComponent {
    post: any;
    constructor() {
        this.post = new Post(Math.random(), "Learn Angular", "Misko Hevery")
    }
}

Data binding inside template:


points: 
 - name attribute must be added 
 -we may add json pipe to test modification
<div>
    <h1>Forms -Template Driven </h1>
    <h1>Post Form</h1>
    <!--todo:remove this once development is over-->
    {{post | json}}
    <form>
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" name="title" [(ngModel)]="post.title" class="form-control" id="title" required>
        </div>

        <div class="form-group">
            <label for="name">Name</label>
            <input type="text" name="author" [(ngModel)]="post.author" class="form-control" id="name" required>
        </div>

        <button type="submit" class="btn btn-success">Submit</button>
    </form>
</div>

5.How to add select control and bind list of values


export class Post {
    constructor(public id: number, public title: string, public author: string,public category:string) { }
}

import { Component } from "@angular/core";
import { Post } from "./models/form.modle";


@Component({
    selector: 'app-post-form',
    templateUrl: 'postform.component.html'
})
export class PostFormComponent {
    post: any;
    categories:Array<string> = ["User Interface","MicroServices","Database","Devops"];
    constructor() {
        this.post = new Post(Math.random(), "Learn Angular", "Misko Hevery",this.categories[0])
    }
}

 <div class="form-group">
            <label for="category">Category</label>
          <select class="form-control" id="category" name="category" required [(ngModel)]="post.category">
                <option *ngFor="let cat of categories" [value]="cat">
                    {{cat}}
                </option>
            </select>
        </div>


..........................................................................................

6.Validation:

Template Reference variable for form tag

<form #postForm> - postForm is reference variable points to "Form Object"
  postForm.formproperty.

<form #postForm="ngForm"> - postForm is reference variable points to "NgForm" Object.

What is NgForm?

ngForm is Object which inherits HTML Form

class ngForm extends HTMLForm{
  All form base class properties
  +extra behavior=>Ready made validation code
  +form submission behviours
}

<form #postForm="ngForm">

The variable postForm is now a reference to the NgForm 
directive that governs the form as a whole.

The NgForm directive:

What NgForm directive? You didn't add an NgForm directive.

Angular did. Angular automatically creates and attaches
 an NgForm directive to the <form> tag.

"The NgForm directive supplements the form element with additional features. 


It holds the controls you created for the elements  with an "ngModel directive" and name attribute,
 and monitors their properties, including their validity.
 
It also has its own valid property which is true only if every contained control is valid."

Note: NgForm is built Object ,has more logic for simlifying our form handling process.

//////////////////////////////////////////////////////////////////////////////////////////////

ngModel:

Track control state and validity with ngModel:
.............................................

ngModel:
> Using ngModel in a form gives you more than just two-way data binding. 

>It also tells you if the user touched the control, if the value changed, or if the value became invalid.

State 	                        Class if true 	Class if false
The control has been visited.  	  ng-touched 	ng-untouched
The control's value has changed.  ng-dirty 	    ng-pristine
The control's value is valid. 	  ng-valid 	    ng-invalid

State Tracking Steps:

1.Look but don't touch.
2.Click inside the name box, then click outside it.
3.Add slashes to the end of the name.
4.Erase the name.

ng-untouched - if you dont touch
ng-touched - if you touch
ng-dirty - if you changed
ng-invalid - if you remove all-empty field.


Add custom CSS for visual feedback:

Valid + Required - green Color
Valid + optional - white color
Invalid (required | optional) - red Color

Angular Css:
.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}


Validation 
<div>
    <h1>Forms -Template Driven </h1>
    <h1>Post Form</h1>
    <!--todo:remove this once development is over-->
    {{post | json}}
    <form #postForm="ngForm">
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" #errorMsg1="ngModel" name="title" [(ngModel)]="post.title" class="form-control"
                id="title" required>

        </div>
        <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
            Title is required
        </div>

        <div class="form-group">
            <label for="name">Name</label>
            <input type="text" name="author" #errorMsg2="ngModel" [(ngModel)]="post.author" class="form-control"
                id="name" required>
        </div>
        <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
            Author is required
        </div>
        <div class="form-group">
            <label for="category">Category</label>
            <select class="form-control" id="category" name="category" required [(ngModel)]="post.category">
                <option *ngFor="let cat of categories" [value]="cat">
                    {{cat}}
                </option>
            </select>
        </div>

        <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>    </form>
</div>

7.Submit form

<div [hidden]="submitted">
    <h1>Forms -Template Driven </h1>
    <h1>Post Form</h1>
    <!--todo:remove this once development is over-->
    {{post | json}}
    <form #postForm="ngForm" (ngSubmit)="onSubmit()">
        <div class="form-group">
            <label for="title">Title</label>
            <input type="text" #errorMsg1="ngModel" name="title" [(ngModel)]="post.title" class="form-control"
                id="title" required>

        </div>
        <div [hidden]="errorMsg1.valid || errorMsg1.pristine" class="alert alert-danger">
            Title is required
        </div>

        <div class="form-group">
            <label for="name">Name</label>
            <input type="text" name="author" #errorMsg2="ngModel" [(ngModel)]="post.author" class="form-control"
                id="name" required>
        </div>
        <div [hidden]="errorMsg2.valid || errorMsg2.pristine" class="alert alert-danger">
            Author is required
        </div>
        <div class="form-group">
            <label for="category">Category</label>
            <select class="form-control" id="category" name="category" required [(ngModel)]="post.category">
                <option *ngFor="let cat of categories" [value]="cat">
                    {{cat}}
                </option>
            </select>
        </div>

        <button type="submit" class="btn btn-success" [disabled]="!postForm.form.valid">Submit</button>
    </form>
</div>

<div class="container" [hidden]="!submitted">
    <h2>You submitted the following:</h2>
    <div class="row">
        <div class="col-xs-3">Id : </div>
        <div class="col-xs-9  pull-left">{{ post.id }}</div>
    </div>
    <div class="row">
        <div class="col-xs-3">Title : </div>
        <div class="col-xs-9  pull-left">{{ post.title }}</div>
    </div>
    <div class="row">
        <div class="col-xs-3">Author : </div>
        <div class="col-xs-9 pull-left">{{ post.author }}</div>
    </div>
    <br>
    <button class="btn btn-primary" (click)="submitted=false">GoBack</button>
</div>
..............................................................................................
				 Services
............................................................................................

ng g m header --module=app   
ng g c header  --flat=true --export=true --inline-style=true --inline-template--skip-tests=true   --module=header


Services are objects in general having application logic.

Types of services:

1.global services
    - services are used by many components 
 eg: logger
2.module specific services
   ProductService


Service Object creations:

Ways 1:
inside module
 -providers:[HelloService]

Way 2: 
 inside service using @Injectable()


import { Injectable } from "@angular/core";
import { GreeterModule } from "./greeter.module";

// @Injectable({
//     providedIn: GreeterModule // uses GreeterModule injector to create service object
// })
@Injectable({
    providedIn: 'root' //uses root Injector to create service Object
})
export class HelloService {
    constructor() {
        console.log('Hello Service is created')
    }
    //biz methods; service methods
    public sayHello(): string {
        return "Hello!!"
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////



Async Services:

1.callback pattern
2.Promise pattern
3.async...await pattern
4.Rxjs


data is available in delayed manner, inside component where should i initalize the data.

constructor()
 inside constructor dont initalize any resource intensive tasks. like ajax calls, web socket class,any async calls.


 ngOnInit(): void {
  }

Component life cycle methods:

in order

- constructor

- ngOnChanges() 

- ngOnInit()

- ngDoCheck()

-ngAfterContentInit()

-ngAfterContentChecked()

-ngAfterViewInit()	

-ngAfterViewChecked()	

-ngOnDestroy()	

All life cycle hooks has interfaces

ngOnInit:
  is called when component is mounted./view is created.

where only we have to write resource intensive tasks, where constructors are used for di only.
import { Component, OnInit } from '@angular/core';
import { HaiService } from './hai.service';

@Component({
  selector: 'app-hai',
  templateUrl: './hai.component.html',
  styles: [
  ]
})
export class HaiComponent implements OnInit {

  message!: string;

  constructor(private service: HaiService) { }

  async ngOnInit(): Promise<void> {
    //callback style
    // this.service.sayHai((message: string) => {
    //   this.message = message
    // })
    //Promises and thenables
    // this.service.sayHai().then(
    //   (message: string) => {
    //     this.message = message;
    //   }
    // ).catch(err => {
    //   console.log(err);
    // })
    this.message = await this.service.sayHai()

  }

}
............................................................................................

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class HaiService {

  message: string = "Hai,Async"

  constructor() { }

  //callback style
  // public sayHai(action:any): void {
  //   setTimeout(action, 5000, this.message)
  // }
  public sayHai(): Promise<string> {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, 5000, this.message)
    });
  }

}
//////////////////////////////////////////////////////////////////////////////////////////////

Rx js integration to replace promises:

Promises are "fire and forget" model

Rxjs(Observables) are streaming model

Streaming adds more benefits:

1.data processing in declartive way.

2.paralle data processing using schdulers

Thats what angular introduced rx js inside angular

Observables Used in angular:
............................

1.You can define custom events that send observable output data from a child to a parent component. - event emitter
2.The HTTP module uses observables to handle AJAX requests and responses.
3.The Router and Forms modules use observables to listen for and respond to user-input events.

Observables is async by default?

 No!

We need to use proper operators and schdulers.

Streaming + NonBlocking(async)

import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators'

@Injectable({
  providedIn: 'root'
})
export class HaiService {

  message: string = "Hai,Async"

  constructor() { }

  //Rxjs-Observable
  public sayHai(): Observable<string> {
    return new Observable<string>(observer => {
      setTimeout(() => { observer.next(this.message) }, 5000)
    }).pipe(map(res => res.toUpperCase()))
  }

}

import { Component, OnInit } from '@angular/core';
import { HaiService } from './hai.service';

@Component({
  selector: 'app-hai',
  templateUrl: './hai.component.html',
  styles: [
  ]
})
export class HaiComponent implements OnInit {

  message!: string;

  constructor(private service: HaiService) { }

  ngOnInit(): void {

    this.service.sayHai().subscribe((message: string) => {
      this.message = message;
    }, err => {

    }, () => {

    })
  }

}
///////////////////////////////////////////////////////////////////////////////////////////////

Code refactoring :

 In the component template, if you want to show result of Observable type

Solutions:

1.using subscribe method
  this.service.sayHai().subscribe((message: string) => {
      this.message = message;
    }, err => {

    }, () => {

    })
2. using pipe called "async"

<div>
    <h2>Async Service</h2>
    <h3>{{message | async}}</h3>
</div>
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { HaiService } from './hai.service';

@Component({
  selector: 'app-hai',
  templateUrl: './hai.component.html',
  styles: [
  ]
})
export class HaiComponent implements OnInit {

  message!: Observable<string>

  constructor(private service: HaiService) { }

  ngOnInit(): void {
    this.message = this.service.sayHai();
  }

}

............................................................................................

import { Injectable } from "@angular/core";
import { of,from,Observable } from "rxjs";
import { delay } from "rxjs/operators";
import { HEROES } from "../mock-data/heroes.mock";
import { Hero } from "../types/hero.type";



@Injectable({
    providedIn: 'root'
})
export class HeroService {
    constructor() { }

    public findAll(): Observable<Hero[]> {
        return of<Hero[]>(HEROES).pipe(delay(6000))
    }

}


import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { Hero } from '../types/hero.type';
import { HeroService } from './heroes.service';

@Component({
  selector: 'app-hero',
  templateUrl: './hero.component.html',
  styles: [
  ]
})
export class HeroComponent implements OnInit {

  heroes!: Observable<Hero[]>

  constructor(private heroservice:HeroService) { }

  ngOnInit(): void {
    this.heroes = this.heroservice.findAll();
  }

}

<ul>
    <li *ngFor="let hero of heroes | async">{{hero.id}} {{hero.name}}</li>
</ul>
.............................................................................................
				AJAX - Programming -  networking from javascript
.............................................................................................

AJAX uses XMLHttpRequest Object for connecting web end points.

We dont use it directly , but every framework uses this internally.

Angular has abstracted XHR with Rxjs(Observable).

Angular HTTP  === Reactive() + Non blocking(async)


@angular/common/http - Package

HttpClientModule - this must be registered



Steps:

1.inject HttpClientModule

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HeroComponent } from './hero.component';
import { HttpClientModule } from '@angular/common/http'



@NgModule({
  declarations: [
    HeroComponent
  ],
  imports: [
    CommonModule, HttpClientModule
  ],
  exports: [
    HeroComponent
  ]
})
export class HeroesModule { }


2.HttpClient 
  is used to communicate with back ends -  wrapper for xhr object.
 
apis to call back ends

-get
-post
-delete
-put

























